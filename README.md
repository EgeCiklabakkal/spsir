Single-pass stratified importance resampling
============================================

Implementation of our paper
["*Single-pass stratified importance resampling*"](https://diglib.eg.org/handle/10.1111/cgf14585) by
[Ege Ciklabakkal](https://cs.uwaterloo.ca/~meciklab/),
[Adrien Gruson](https://profs.etsmtl.ca/agruson/),
[Iliyan Georgiev](http://iliyan.com/),
[Derek Nowrouzezahrai](http://www.cim.mcgill.ca/~derek/), and
[Toshiya Hachisuka](https://cs.uwaterloo.ca/~thachisu/).

The implementation builds on the [pbrt, version 3](https://github.com/mmp/pbrt-v3)
renderer.
The project can be built in [the same way as pbrt](https://github.com/mmp/pbrt-v3/blob/master/README.md).

For further details, we refer to the
[project webpage](http://iliyan.com/publications/StratifiedResampling).

Scenes
------
We include the scenes used to generate the renderings in the paper.
For further details on the scenes we refer to [README](scenes/README.md).

Note that in all scenes, ray per pixel is set to 1 and
these primary rays go through the center of the pixels.
We do so to focus on the variance (reduction) from
[resampled importance sampling (RIS)](https://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=1662&context=etd).
Our method can be extended to multiple sample per pixel by using a low-discrepancy
sequence to sample the primary rays and querying the blue-noise mask with
independent offsets. [Previous work](https://developer.nvidia.com/blog/rendering-in-real-time-with-spatiotemporal-blue-noise-textures-part-2/) has found that the
[R<sub>2</sub>-sequence](http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/) is a good choice for such offset.

To reproduce the exact figures, some modifications to the code would be necessary
(For example, fig. 6 reorders the candidates after they are generated,
which is not our exact algorithm), however our main method is implemented to cover
each sampling problem we present in the paper.

Code Organization
-----------------
The following is the list of changed / new files for our method:

#### 1. `src/core/api.cpp`
Parse and make medium `HomogeneousBlockingMedium`

#### 2. `src/core/dithermask.*`
Class for `DitherMask` of any dimension.
Should be used with dither masks created by
[Dithering Mask Generator](https://github.com/beltegeuse/dithering-mask)

#### 3. `src/core/hilbertcurve.*`
Class for `HilbertCurve` of any dimension.
The main interface is the `sample` function which returns the
primary sample space candidate (all components in \[0,1\)) along the
Hilbert Curve, given a random number `u`.
There is also the simpler 2D version `HilbertCurve2D` for better performance.

#### 4. `src/core/integrator.*`
Includes many functions implementing our method.

`[Reservoir,InverseCDF,BidirectionalCDF]LightOnly(...)` functions implement
[RIS](https://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=1662&context=etd)
with 2D candidates of light samples,
using reservoir sampling, inverse CDF sampling, and
our bidirectional CDF sampling respectively.
Reservoir sampling doesn't utilize our Hilbert Curve reordering and instead
uses low-discrepancy sequences
(this is also the case for other sampling problems).
It serves as a reasonable baseline.
The other methods do utilize the Hilbert Curve reordering.

`[Reservoir,InverseCDF,BidirectionalCDF]BSDFEnvMIS(...)` functions implement
RIS with candidates generated by sampling either the BSDF or the environment light.
The candidates are then weighted by
[multiple importance sampling (MIS)](http://graphics.stanford.edu/papers/veach_thesis/thesis.pdf).
This weighting is the same as
*Sec. 4.6.1 Multiple Importance Sampling applied to Proposals* from
[Talbot's thesis](https://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=1662&context=etd)
These functions assume that there is only the environment map as the light.
Our goal here is to show that we can combine our method with MIS.

There are also functions related to volume sampling.

#### 5. `src/core/light.*`
Virtual method so sample light and return pdf in area measure
(instead of solid angle measure).

#### 6. `src/core/medium.h`
`enum class` of volume sampling strategies
`RISReservoir, RISInverseCDF, RISBidirectionalCDF`
along virtual methods for our volume sampling experiments.

#### 7. `src/core/reservoir.h`
Implements the `Reservoir` class, also includes the classes for candidates.

#### 8. `src/core/sampler.*`
Implements the [R<sub>2</sub>-sequence](http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/) to offset the `DitherMask`.
This offset is controlled by a seed provided by the user.
Different offsets can be used to generate multiple outputs to be averaged.

#### 9. `src/core/shape.*`
Virtual method to help return area measure when sampling lights.

#### 10. `src/integrators/directlighting.*` and `src/integrators/volpath.*`
Integrator modified to read variables needed for our methods and call them appropriately.

#### 11. `src/lights/diffuse.*` and `src/lights/point.*`
Sample lights and return pdf in area measure.

#### 12. `src/media/homogeneousblocking.*`
Implements the `HomogeneousBlockingMedium` that represents the volume such that
the ray inside it always samples a medium interaction.
In other words, the objects inside the medium are never shaded,
but they affect the maximum distance if the ray.
Therefore we can *see* the objects in a way, however they are not shaded.
This medium allows us to focus only on sampling a distance along the ray.
In our experiments, the volume always exists throughout the whole scene
(it is not confined in an object).

For the first experiment, we consider a single point light inside the
homogeneous medium and single scattering as the sampling problem
(i.e. sampling distance along primary rays).
The relevant method is `SampleLightDriven(...)`
(samples according to the given light) which calls
`SampleRIS[Reservoir,iCDF,Bidirectional]LightDriven(...)` similarly to our
2D direct lighting experiments.

For the second experiment, our goal is to sample distance along the ray and
a direction to some (area) light so that our candidates are 3D.
The relevant method is `SampleDistDir(...)` which calls
`SampleRIS[Reservoir,iCDF,Bidirectional]DistDir(...)`.

How to cite
-----------

```
@article{Ciklabakkal:2022:StratifiedResampling,
  author = {Ege Ciklabakkal and Adrien Gruson and Iliyan Georgiev and Derek Nowrouzezahrai and Toshiya Hachisuka},
  title = {Single-pass stratified importance resampling},
  journal = {Computer Graphics Forum (Proceedings of EGSR)},
  year = {2022},
  number = {4},
  volume = {41}
}
```
